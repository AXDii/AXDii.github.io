---
title: 多线程编程-第二章：多线程编程的目标与挑战
layout: article
tags: 多线程编程
---

### 串行、并发与并行

- 串行：顺序逐一完成几件事情
- 并发：时间片切换，换着做事情（在一段时间内以交替的方式去完成多个任务）
- 并行：相当于几个人互不干扰地同时完成几件事（以齐头并进的方式去完成多个任务）

多线程编程实质：**将任务的处理方式由串行改为并发，即实现并发化。**



### 竞态

概念：多线程编程中经常遇到一个问题就是**对于同样的输入，程序的输出有时候是正确的而有时候却是错误的**。这种一个**计算结果的正确性与时间有关的现象**被称为**竞态**。

- 竞态的定义：竟态是指计算的正确性依赖于相对时间顺序或者线程的交错。 

- 状态变量：即类的实例变量、静态变量。

- 共享变量：即可以被多个线程共同访问的变量。

导致竞态的常见因素是多个线程在没有采取任何控制措施的情况下并发地更新、读取同一个共享变量。

竞态的两种模式：read-modify-write（读-改-写）和check-then-act（检测而后行动）。

- 对于read-modify-write：共有三个步骤：读取一个共享变量的值（read），然后根据该值做一些计算（modify），接着更新该共享变量的值（write）。一个线程在执行完指令read之后到开始（或者正在）执行指令modify的这段时间内**其他线程可能已经更新了共享变量（sequence）的值**，**这就使得该线程在执行指令modify时使用的是共享变量的旧值（读脏数据）**。接着，该线程把根据这个旧值计算出来的结果更新到共享变量，而这又使得其他线程对该共享变量所做的更新“被覆盖”，即造成了更新丢失。
- 对于check-than-act：共有两个步骤：读取某个共享变量的值，根据该变量的值决定下一步的动作是什么。
- 对于局部变量（包含形式参数和方法体内定义的变量），由于不同的线程各自访问的是各自的那一份局部变量，因此局部变量的使用不会导致竞态。

解决竞态的方式：使用synchronized关键字，会使其修饰的方法在任一时刻只能够被一个线程执行。



### 线程安全性

​		概念：如果一个类在单线程环境下能够运作正常，并且在多线程环境下，在其使用方不必为其做任何改变的情况下也能够运作正常，那么我们就称其是**线程安全**（Thread-safe）的，相应地我们称这个类具有线程安全性（Thread-safety）。反之，就是非线程安全的。因此，**一个类如果能导致竞态，则这个类是非线程安全的；而一个类如果是线程安全的，那么它不会导致竞态。但不存在竟态却未必意味着线程安全。**

​       一个类如果不是线程安全的，我们就说它在多线程环境下直接使用存在**线程安全问题**。线程安全问题概括来说表现为3个方面：原子性、可见性和有序性。

 

### 线程安全问题：

- 原子性：原子操作，其操作从执行线程以外的任何线程来看是不可分割的。当一个操作具备原子性也就消除了这个操作导致竞态的可能性。总的来说，**Java中有两种方式来实现原子性**。
  - **一种是使用锁（Lock）**：锁具有排他性，即它能够保障一个共享变量在任意时刻只能够被一个线程访问。
  - **另一种是利用处理器提供的专门CAS（Compare-and-Swap）指令**，CAS指令实现原子性的方式与锁实现原子性的方式实际上是相同的，差别在于锁通常是在软件这一层次实现的，而CAS是直接在硬件（处理器和内存）这一层次实现的，它可以被看做“硬件锁”。

对于Java来说，long型和double型以外的任何类型的变量（不是对象）的写操作都是原子操作。因此在多个线程并发访问同一long/double型变量的情况下，一个线程可能会读取到其他线程更新该变量的“中间结果”（在32位的JVM才能够看到效果）。因此，要在32位JVM中保证long/double型的写操作具有原子性，需要使用volatile关键字修饰。并且需要注意的是，原子操作+原子操作是**不等于**原子操作的。



- 可见性：在多线程环境下，如果一个线程对某个共享变量进行更新之后，后续访问该变量的线程可以读取到该更新的结果，那么我们就称这个线程对该共享变量的更新对其他线程可见，否则就称不可见。可见性就是指一个线程对共享变量的更新s的结果对于读取相应共享变量的线程而言是否可见的问题。
- 保证可见性：**使用volatile修饰变量**，其作用是阻止JIT编译器做出不正常的优化

- 有序性：指在什么情况下一个处理器上运行的一个线程所执行的内存访问操作在另外一个处理器上运行的其他线程看来是乱序的。**所谓乱序，是指内存操作的顺序看起来是发生了变化。**

  

在多核处理器的环境下，操作执行顺序可能是没有保障的：编译器可能改变两个操作的先后顺序。这种现象叫作重排序。

- 重排序：重排序是对内存访问有关的操作（读和写）所做的一种优化，它可以在不影响单线程程序正确性的情况下提升程序的性能。但是，它可能对多线程程序的正确性产生影响，即它**可能导致线程安全问题**。与可见性问题类似，重排序页不是必然出现的。
- 指令重排序：在源代码顺序与程序顺序不一致，或者程序顺序与执行顺序不一致的情况下，我们就说发生了指令重排序。

Java平台中包含两种编译器：静态编译器（javac）和动态编译器（JIT）。前者的作用是将Java源代码（.java文本文件）编译为字节码（.class）二进制文件。它是在代码编译阶段介入的。后者的作用是将字节码动态编译为Java虚拟机宿主机的本地代码（机器码），它是在Java程序运行过程中介入的。**Java中发生指令重排序，很有可能是在JIT编译时发生的。Java基本上不会执行指令重排序。**

- 重排序具有的两个特征：

  - 重排序可能导致线程安全问题。
  - 重排序不是必然出现的。

- 然而，处理器也可能执行指令重排序，这使得执行顺序与程序顺序不一致。处理器堆指令进行重排序也被称为处理器的乱序执行。但由于指令的执行结果的提交仍然是按照程序顺序来的，因此处理器的指令重排序并不会对单线程程序的正确性产生影响。

- 存储子系统重排序：即使在处理器严格依照程序顺序执行两个内存访问操作的情况下，在存储子系统的作用下其他处理器对这两个操作的感知顺序仍然可能与程序顺序不一致，即这**两个操作的执行顺序看起来像是发生了变化**。这种现象就是**存储子系统重排序**，也被称为内存重排序。存储子系统重排序是一种现象而不是一种动作，它没有真正对指令执行顺序进行调整，而只是造成一种指令的执行顺序像是被调整过一样的现象，其重排序的对象是内存操作的结果。

  为了方便表示：称存储子系统重排序为：内存操作中操作Y被重排序到操作X之前。

  **内存重排序可能导致线程安全问题。**

- 貌似串行语义：重排序遵循“貌似串行语义”对指令进行重排序。貌似串行语义只是从单线程程序的角度保证重排序后的运行结果不影响程序的正确性，并不保证多线程环境下程序的正确性。

为了保证貌似串行语义，存在数据依赖关系的语句不会被重排序。如果两个操作（指令）访问同一个变量（地址），且其中一个操作（执行）为写操作，那么这两个操作之间就存在数据依赖关系。

存在控制依赖关系的语句是可以被重排序的。如果一条语句（指令）的执行结果会决定另一条语句（指令）能否执行，那么这两条语句（指令）之间就存在控制依赖关系。

存在控制依赖关系的语句最典型的就是if语句中的条件表达式和相应的语句体。允许这种重排序意味着处理器可能先执行if语句体所涉及的内存访问控操作，然后再执行相应的条件判断。

- **保证内存访问的顺序性：禁止重排序，实际上是指逻辑上的部分禁止重排序**。因为从物理上禁止重排序会使得处理器性能严重下降。
- **禁止重排序的关键字：volatile、synchronized等**

扩展：可见性是有序性的基础。

- **上下文切换**

- - 概念：**一个线程被暂停**（即被剥夺处理器的使用权）**，另一个线程被选中开始或者继续运行的过程称为线程上下文切换。**相应地，一个线程被剥夺处理器的使用权**而被暂停运行就被称为切出**；一个线程被操作系统选中占用处理器开始或者**继续其运行就被称为切入**。
- 上下文的概念：可见的连续运行的线程，实际上是以断断续续的方式使其任务进展的。这种方式意味着再切除和切入的时候操作系统需要保存和恢复相应线程的进度信息，**即切入和切出那一刻相应线程所执行的任务进行到什么程度了。这个进度信息就被称为上下文。**在切出时，操作系统需要将上下文保存到内存中。在切入时，操作系统需要从内存中加载（恢复）被选中线程的上下文。
  - 从java角度看，一个线程的生命周期状态再runnable状态与非runnable状态之间切换的过程就是一个上下文切换的过程。当一个线程的生命周期状态由runnable转换为非runnable时，称线程被暂停；反之，称为被唤醒。一个线程被唤醒仅代表该线程获得一个继续运行的机会，而并不代表其立即可以占用处理器运行。因此，当被唤醒的线程被操作系统选中占用处理器继续其运行的时候，操作系统会恢复之前为该线程保存的上下文，以便在此基础上运行。
- 上下文切换的分类及具体诱因：
    - 自发性上下文切换：
    - 概念：自发性上下文切换由于其自身因素导致的切出。
      - 导致自发性上下文切换的原因：
      - Thread.sleep(long millis)
        - Object.wait()/wait(long timeout)/wait(long timeout,int nanos)
      - Thread.yield()
        - Thread.join()/Thread.join(long timeout)
      - LockSupport.park()
        - 线程发起I/O操作或者等待其他线程持有锁
  - 非自发性上下文切换：
      - 概念：指线程由于线程调度器的原因被迫切出。
      - 发生原因：
  
        - 被切出线程的时间片用完
        - 有一个比被切出线程优先级更高的线程需要被运行
        - Java虚拟机的垃圾回收动作（Stop-the-world）
- 上下文切换的开销和测量
    - 直接开销
  - 操作系统保存和恢复上下文所需的开销，这主要是处理器时间开销
      - 线程调度器继续宁线程调度的开销
    
    - 间接开销

      - 处理器高速缓存重新加载的开销
      - 上下文切换也可能会导致整个一级告诉缓存中的内容被冲刷
  - 线程的活性故障：
  - 概念：线程由于其他原因一直处于非runnable以及处于runnable但是其要执行的任务却一直无法执行的现象被称为线程活性故障。
    - 种类：

      - 死锁：A持有X资源等待Y资源，B持有Y资源等待X。
    - 锁死：需要有一个唤醒该线程的前提线程，但前提线程出现问题导致无法唤醒该线程。
      - 活锁：执行任务但没有进展。
      - 饥饿：线程因无法获得其所需的资源而使得任务执行无法进展的现象。
- 资源争用与调度：
  - 概念：在一个线程占用一个排他性资源进行访问（读、写操作）而未释放其对资源所有权的时候，其他线程试图访问该资源的现象被称为资源争用。

在多个线程申请同一个排他性资源的情况下，决定哪个线程会被授予该资源的独占权，即选择哪个申请者占有该资源的过程就是资源的调度。

- 资源的公平性：如果资源的任何一个先申请者总是能够比任何一个后申请者先获得该资源的独占权，则称相应的资源调度策略是公平的。反之，是不公平的。

 

### 总结：

- 单线程程序所进行的计算本质上是串行的。多线程编程的目标是将原本串行的计算改为并发乃至并行。
- 竟态是指计算的正确性依赖于相对时间顺序或者线程的交错。竟态的结果不一定是错误的。**线程安全意味着不存在竟态，但是不存在竟态却未必意味着线程安全。**
- 线程安全问题表现为原子性、可见性和有序性这三方面。三者相互区别又相互联系。原子性的保障能够消除竟态。可见性描述了一个线程对共享变量的更新对于另外一个线程而言是否可见，或者说什么情况下可见的问题。原子性和可见性一同得以保障了一个线程能够共享变量的相对新值。可见性是有序性的基础，而有序性又有可能影响可见性。
- 编译器、处理器、存储子系统和运行时（JIT编译器）都有科恩那个导致重排序。有序性的保障是通过部分地从逻辑上禁止重排序实现的。
- 上下文切换科恩那个被看作多线程编程的必然产物，一方面它是的充分利用极其有限的处理器资源成为科恩那个；另一方面它也增加了开销。
- 非公平资调度策略是我们多数情况下的首选资源调度策略。其有点是吞吐率角大，缺点是资源申请者申请资源所需的时间偏差可能角大，并可能导致饥饿现象。公平调度策略适合在资源的持有线程占用资源的时间相对长或资源的平均申请时间间隔相对长的情况下，或者对资源申请所需的时间偏差有所要求的情况下使用。其优点是线程申请资源所需的时间偏差较小，并且不会导致饥饿现象；其缺点是吞吐率较小。