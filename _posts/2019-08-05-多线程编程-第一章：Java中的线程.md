---
title: 多线程编程-第一章：Java中的线程
layout: article
tags: 多线程编程
---

### 进程、线程与任务

**进程是程序的运行实例。**进程与线程的关系好比播放中的视频与相应的视频文件。进程是程序向操作系统申请资源的基本单位。

**线程是进程中可独立执行的最小单位。**一个进程中可以包含多个进程。同一个进程中的所有线程共享该进程的资源，如内存空间、文件句柄等。

进程与线程的关系，好比一个营业中的饭店与其正在工作中的员工之间的关系。



### Java线程API简介
* 线程的创建、启动与运行：

  - 使用Thread类的两个常用构造器：`Thread()`和Thread(Runnable target)定义Thread类的子类，覆写run方法：

    ```Java
    class MyThread extends Thread{
    	void run(){ //do something… }
    } 
    Thread t = new MyThread();
    t.start();//启动
		```
	- 实现Runnable接口，然后以该Runnable接口实例作为构造器的参数直接创建一个Thread类的实例。
	```Java
	new Thread(()->{ //do something…  }).start();
	```
	- Thread和runnable区别，thread不共享，runnable共享，是因为thread.run方法的实现如下：
	```Java
	public void run() {
		if (target != null) {
			target.run();
		}
	}
	```
	即，对于继承thread来说，是独立的，对于runnable（为target）来说，使用的是组合方式，是资源共享的。
	

线程的属性：
* 编号（ID），只读
* 名称（Name）：Thread-编号
* 线程类别（Daemon）：boolean类型，值为true为守护进程，false为用户进程，`setDaemon()`方法需要在`start()`方法调用之前调用。
* 优先级（Priority）：int，一般使用默认优先级即可。

注意，Java线程的**优先级使用不当**或者滥用则可能导致某些线程永远无法得到运行，即产生了**线程饥饿**。

按照线程时候会阻止Java虚拟机正常停止，我们可以将Java中的线程分为**守护线程**和**用户线程**。用户线程会阻止Java虚拟机的正常停止，即**一个Java虚拟机只有在其所有用户线程都停止运行结束（即Thread.run()调用未结束）的情况下才能正常停止；而守护线程则不会影响Java虚拟机的正常停止**。因此，**守护线程通常用于执行一些重要性不是很高的任务**，例如用于监视其他线程的运行状况。

### Thread类的常用方法

| 方法                              | 功能                                                         | 备注                                                         |
| --------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| static   Thread   currentThread() | 返回当前线程，即当前代码的执行线程（对象）                   | 同一段代码对Thread.currentThread()的调用，其返回值可能对应着不同的线程（对象） |
| void run()                        | 用于实现线程的任务处理逻辑                                   | 该方法时由虚拟机直接调用的，一般情况下应用程序不应该调用该方法 |
| void start()                      | 启动相应线程                                                 | 该方法的返回值并不代表相应的线程已经被启动。一个Thread实例的start方法只能够被调用一次，多次调用会导致异常的抛出 |
| void join()                       | 等待相应线程运行结束                                         | 若线程A调用线程B的join方法，那么线程A的运行会被暂停，直到线程B运行结束 |
| static void yield()               | 使当前程序主动放弃其对处理器的占用，着可能导致当前线程被暂停 | 这个方法是不可靠的。该方法被调用时当前线程可能仍然继续运行（视系统当前的运行状况而定） |
| static void sleep(long   millis)  | 使当前线程休眠（暂停运行）指定的事件                         |                                                              |

### 线程的层次关系
层次分为：父线程、子线程（子线程在其他情况下也可以作为父线程）
**一个线程是否是一个守护线程默认取决于其父线程**：默认情况下，父线程是守护线程，则子线程也是守护线程；父线程是用户线程，则子线程也是用户线程。

**一个线程的优先级默认值为该线程的父线程优先级。**

习惯上，我们也称某些子线程为工作者线程。工作者线程通常是其父线程创建来用于专门负责某项特定任务的执行的。

### java线程状态
* 新建（New）
* 运行（Runnable）：包含Ready以及Running
* 阻塞（Blocked）
* 无限等待（Waiting）
* 限时等待（Timed_Waiting）
* 终止（Terminated）

其中，在一个线程的整个生命周期中，new和terminated状态都只能有一次。

### 线程的监控
使用线程转储（Thread Dump）可以对线程进行监控。
可以使用`jstatck -l PID`命令、或使用jvisualvm中的Thread Dump按钮。

### 多线程编程的优缺点：

* 优点：
  * 提高系统的吞吐率
  * 提高响应性
  * 充分利用多核处理器资源
  * 最小化对系统资源的使用
  * 简化程序的结构
* 缺点：
  * 线程安全问题
  * 线程活性问题
  * 上下文切换
  * 可靠性